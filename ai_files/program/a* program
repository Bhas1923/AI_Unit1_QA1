import java.util.*;

public class AStar_Hanoi_Steps {

    static class State {
        List<Integer>[] pegs;
        List<String> moves;

        State(List<Integer>[] p, List<String> m) {
            pegs = new ArrayList[3];
            for (int i = 0; i < 3; i++)
                pegs[i] = new ArrayList<>(p[i]);
            moves = new ArrayList<>(m);
        }

        boolean isGoal() {
            return pegs[0].isEmpty() && pegs[1].isEmpty() && pegs[2].equals(Arrays.asList(3,2,1));
        }

        int heuristic() {
            return 3 - pegs[2].size(); // disks not on goal peg
        }

        List<State> getNextStates() {
            List<State> res = new ArrayList<>();
            for (int i = 0; i < 3; i++) {
                if (pegs[i].isEmpty()) continue;
                int disk = pegs[i].get(pegs[i].size() - 1);

                for (int j = 0; j < 3; j++) {
                    if (i == j) continue;
                    if (pegs[j].isEmpty() || pegs[j].get(pegs[j].size() - 1) > disk) {
                        List<Integer>[] newPegs = new ArrayList[3];
                        for (int k = 0; k < 3; k++)
                            newPegs[k] = new ArrayList<>(pegs[k]);

                        newPegs[j].add(newPegs[i].remove(newPegs[i].size() - 1));

                        List<String> newMoves = new ArrayList<>(moves);
                        newMoves.add("Move disk " + disk + " from Peg " + (i+1) + " to Peg " + (j+1));

                        res.add(new State(newPegs, newMoves));
                    }
                }
            }
            return res;
        }

        @Override
        public int hashCode() {
            return Arrays.deepHashCode(pegs);
        }

        @Override
        public boolean equals(Object o) {
            return Arrays.deepEquals(pegs, ((State)o).pegs);
        }
    }

    static class Node {
        State state;
        int g, f;
        Node parent;

        Node(State s, int g, Node parent) {
            state = s;
            this.g = g;
            this.f = g + s.heuristic();
            this.parent = parent;
        }
    }

    public static void main(String[] args) {

        List<Integer>[] pegs = new ArrayList[3];
        pegs[0] = new ArrayList<>(Arrays.asList(3,2,1));
        pegs[1] = new ArrayList<>();
        pegs[2] = new ArrayList<>();

        State initial = new State(pegs, new ArrayList<>());

        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(n -> n.f));
        Map<State, Integer> cost = new HashMap<>();

        pq.add(new Node(initial, 0, null));
        cost.put(initial, 0);

        Node goalNode = null;

        while (!pq.isEmpty()) {
            Node cur = pq.poll();

            if (cur.state.isGoal()) {
                goalNode = cur;
                break;
            }

            for (State nxt : cur.state.getNextStates()) {
                int newCost = cur.g + 1;

                if (!cost.containsKey(nxt) || newCost < cost.get(nxt)) {
                    cost.put(nxt, newCost);
                    pq.add(new Node(nxt, newCost, cur));
                }
            }
        }

        // Print the moves
        System.out.println("A* Solution Steps:");
        for (String move : goalNode.state.moves) {
            System.out.println(move);
        }
        System.out.println("Total moves: " + goalNode.state.moves.size());
    }
}
